# 对虚拟内存区域的操作

- 每个VMA描述符(struct vm_area_struct)表示一个线性地址区间。
- 进程所拥有的线性区间从来不重叠，并且内核经历吧新分配的线性区与紧邻的现有线性区间进行合并。如果两个相邻的访问权限能够匹配，就能将他们合并在一起。

如图所示，当一个新的线性区间加入到进程的地址空间时，内核检查一个已经存在的线性区是否可以扩大(a)。如果不能，就创建一个新的线性区(b)。如果从进程地址空间删除一个线性区间，内核就要调整受影响的线性区的大小(c)。调整大小迫使一个线性区被分成两个更小的部分。

![](image/MemoryRegions01.png)

## 查询虚拟地址相关的区域

通过虚拟地址，`find_vma`可以查找包含给定地址的地址区域，即满足`addr < vm_area_struct->vm_end`条件的第一个区域。该函数的参数不仅包括虚拟地址（addr），还包括一个指向mm_struct实例的指针，后者指定了扫描哪个进程的地址空间。

```c
struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr)
{
	struct vm_area_struct *vma = NULL;
	if (mm) {
		vma = mm->mmap_cache;
        /* 内核首先检查上次处理的区域（现在保存在mm->mmap_cache）中是否包含所需的地址，即是否
           该区域的结束地址在目标地址之后，而起始地址在目标地址之前。否则在红黑树中查询 */
		if (!(vma && vma->vm_end > addr && vma->vm_start <= addr)) {
			struct rb_node * rb_node;

			rb_node = mm->mm_rb.rb_node;
			vma = NULL;

			while (rb_node) {
				struct vm_area_struct * vma_tmp;

				vma_tmp = rb_entry(rb_node,
						struct vm_area_struct, vm_rb);
                /* 如果目标地址小于当前区域，则从左子结点开始；如果当前区域的结束地址小于等于目标地址，则从右子结点开始 */
				if (vma_tmp->vm_end > addr) {
					vma = vma_tmp;
					if (vma_tmp->vm_start <= addr)
						break;
					rb_node = rb_node->rb_left;
				} else
					rb_node = rb_node->rb_right;
			}
			if (vma)
				mm->mmap_cache = vma;
		}
	}
	return vma;
}
```
`find_vma_intersection`确认边界为`start_addr`和`end_addr`的区间是否完与现存区域有交集。它基于`find_vma`实现
```c
static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
{
	struct vm_area_struct * vma = find_vma(mm,start_addr);
	if (vma && end_addr <= vma->vm_start)
		vma = NULL;
	return vma;
}
```

